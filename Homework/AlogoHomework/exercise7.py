"""
    Exercise (7). 在一条街上有 n 所房子，H[i] (1 ≤ i ≤ n) 是第 i 所房子离街道 起点处的距离 (以米为单位)，
                  假定 H[1] < H[2] < ··· < H[n]。目前该街道上 还没有一所邮局，现计划新建若干所邮局，使得每所房子到最近的邮局距离在100米以内。
                  试设计一个时间复杂度为 O(n) 的算法，计算出新建邮局的位 置，即每所新建邮局离街道起点处的距离 P [j] (1 ≤ j ≤ m)，同时确保新建邮 局个数 m 最小。
"""
'''
    这道题主要使用贪心策略。
    H列表存储每个房子到街道起点的距离，P列表存储每个邮局到街道起点的距离。
    根据题意，就是要让邮局的覆盖范围最大化。首先设置第一个邮局P[1]时，P[1] = H[1] + 100 是最合适的位置。
    之后的房子只要在 | H[n-1] - P[1] | <= 100的范围内，都不需要另设邮局。
    假设第n个房子在 | H[n-1] - P[1] | <= 100 的范围外，则按照设第一个邮局的方式再设邮局，即 P[2] = H[n] + 100，以此类推。
    对最后一个房子，只要将邮局设在房子的位置即可，不需要再加100。
'''


def postOffice_Site_Selection(P, H):
    P.append(H[0] + 100)  # 设定第一个邮局的位置
    c = 0  # 邮局列表下标
    for i in range(1, len(H)):
        if H[i] > P[c]+100:  # 房子不在邮局范围内的情况
            P.append(H[i] + 100)
            c += 1
    if P[c] > H[len(H)-1]:  # 设定最后一个邮局的位置
        P[c] = H[len(H)-1]
    return c+1


if __name__ == '__main__':
    H = [25, 125, 375, 500, 800]  # 每个房子到街道起点的距离
    P = []  # 每个邮局到街道起点的距离
    m = postOffice_Site_Selection(P, H)
    print('邮局的数量为：' + m)
    print('邮局的距离为：' + P)


